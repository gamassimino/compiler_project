package CodeGenerated;

import ASTClass.*;
import java.util.*;
import java_cup.runtime.*;
import Visitor.*;
import TableOfHash.Hash;

terminal String BOOL, INTEGER, FLOAT;
terminal BREAK, CONTINUE;
terminal IF, ELSE;
terminal FOR, WHILE;
terminal String VOID;
terminal CLASS;
terminal RETURN, EXTERN;
terminal SEMI, COMMA;
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LKEY, RKEY;
terminal AND, OR, NOT;
terminal PERCENTAGE, DIVIDED,PLUS, MINUS, TIMES;
terminal LESS, LESSOREQ;
terminal GREATER, GREATEROREQ;
terminal EQUALTO, NOTEQUALTO;
terminal ADDASSIGNMENT, SUBASSIGNMENT, ASSIGNMENT;
terminal POINT;
terminal String ID;

terminal IntLiteral NUMBER_I;
terminal FloatLiteral NUMBER_F;
terminal BoolLiteral BOOLEAN_VALUE;

non terminal Expression expr;

non terminal LocationExpr location_expr;
non terminal LocationStmt location_stmt;
non terminal MethodCallExpr method_call_expr;
non terminal MethodCallStmt method_call_stmt;
non terminal Program program;
non terminal FieldDecl field_decl;
non terminal MethodDecl method_decl;
non terminal ClassDecl class_decl;
non terminal Type type;
non terminal Param param;
non terminal Body body;
non terminal Block block;
non terminal Statement statement;
non terminal Statement optional_else;
non terminal Navigation navigation;
non terminal ArrayList<Expression> method_expr;
non terminal Statement lambda;
non terminal ArrayList<IdName> id_list;
non terminal IdName id_name;
non terminal ArrayList<FieldDecl> field_decl_list;
non terminal Navigation location_aux;
non terminal ArrayList<Statement> list_statement;
non terminal ArrayList<MethodDecl> method_decl_list;

precedence left OR;
precedence left AND;
precedence left EQUALTO, NOTEQUALTO;
precedence left LESS, LESSOREQ, GREATER, GREATEROREQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDED, PERCENTAGE;
precedence left NOT;
precedence left ELSE;

precedence left RPAREN;
precedence left LPAREN;
precedence left LBRACKET;

start with program;

// ### Expression ###
expr ::= location_expr:lo {: RESULT = lo; :}
       | method_call_expr :m_c_e {: RESULT = m_c_e; :}
       | NUMBER_I:in {: RESULT = in; :}
       | NUMBER_F:fl  {: RESULT = fl; :}
       | BOOLEAN_VALUE:bool {: RESULT = bool; :}
       | expr:l PLUS expr:r {: RESULT = new Plus(l, r); :}
       | expr:l MINUS expr:r {: RESULT = new Minus(l, r); :}
       | expr:l TIMES expr:r {: RESULT = new Times(l, r); :}
       | expr:l DIVIDED expr:r {: RESULT = new Divided(l, r); :}
       | expr:l PERCENTAGE expr:r {: RESULT = new Percentage(l, r); :}
       | expr:l LESS expr:r {: RESULT = new Less(l, r); :}
       | expr:l GREATER expr:r {: RESULT = new Greater(l, r); :}
       | expr:l LESSOREQ expr:r {: RESULT = new LessOrEq(l, r); :}
       | expr:l GREATEROREQ expr:r {: RESULT = new GreaterOrEq(l, r); :}
       | expr:l EQUALTO expr:r {: RESULT = new EqualTo(l, r); :}
       | expr:l NOTEQUALTO expr:r {: RESULT = new NotEqualTo(l, r); :}
       | expr:l AND expr:r {: RESULT = new And(l, r); :}
       | expr:l OR expr:r {: RESULT = new Or(l, r); :}
       | MINUS expr:e {: RESULT = new Minus(e); :}
       | NOT expr:e {: RESULT = new Not(e) ; :}
       | LPAREN expr:exp RPAREN {: RESULT = exp; :};

// ### Program ###
program ::= class_decl:cl {: RESULT = new Program(cl); :}
          | program:p class_decl:cl {: p.addClass(cl); RESULT = p; :};

// ### Class Declaration ###
class_decl ::= CLASS ID:id LKEY field_decl_list:f_d_l method_decl_list:m_d_l RKEY {: RESULT = new ClassDecl(new IdName(id), f_d_l, m_d_l) ;:}
             | CLASS ID:id LKEY field_decl_list:f_d_l RKEY {: RESULT = new ClassDecl(new IdName(id), f_d_l, true) ;:}
             | CLASS ID:id LKEY method_decl_list:m_d_l RKEY {: RESULT = new ClassDecl(new IdName(id), m_d_l, false) ;:}
             | CLASS ID:id LKEY RKEY {: RESULT = new ClassDecl(new IdName(id)) ;:};

// ### Field Declaration ###
field_decl_list ::= field_decl:f_d {: ArrayList<FieldDecl> list = new ArrayList<FieldDecl>();
                                      for (ArrayList<FieldDecl> list_f_d: f_d) {list.add(list_f_d);}
                                      RESULT = list; :}
                  | field_decl_list:f_d_l field_decl:f_d {: f_d_l.add(f_d); RESULT = f_d_l; :};

field_decl ::= type:t id_list:i_l SEMI {: list = new ArrayList<FieldDecl>();
                                          for (IdName i : i_l) {list.add(new FieldDecl(t,i));}
                                          RESULT = list; :};

// ### Identifier ###
id_list ::= id_name:i_n {: ArrayList<IdName> list = new ArrayList<IdName>();
                      list.add(i_n);
                      RESULT = list;
                    :}
          | id_list:i_l COMMA id_name:i_n {: i_l.add(i_n); RESULT = i_l; :};


// This is never watched
id_name ::= ID:id {: RESULT = new IdName(id) ;:}
          | ID:id LBRACKET NUMBER_I:s RBRACKET {: RESULT = new IdName(id, s) ;:};

// ### Method Declaration ###
method_decl_list ::= method_decl:m_d {: ArrayList<MethodDecl> list = new ArrayList<MethodDecl>();
                                        list.add(m_d);
                                        RESULT = list;
                                     :}
                   | method_decl_list:m_d_l method_decl:m_d {: m_d_l.add(m_d); RESULT = m_d_l; :};

method_decl ::= type:t ID:id LPAREN param:p RPAREN body:b {: RESULT = new MethodDecl(t, new IdName(id), p, b) ;:}
              | type:t ID:id LPAREN RPAREN body:b {: RESULT = new MethodDecl(t, new IdName(id), new Param(null), b) ;:};

// ### Parameters ###
param ::= type:t ID:id {: RESULT = new Param(t, new IdName(id)) ;:}
        | type:t ID:id COMMA param:p {: p.addParam(t, new IdName(id));  RESULT = p; :}; // REFACTOR CLASS PARAM

// ### Body ###
body ::=  block:bl {: RESULT = new Body(bl) ;:}
        | EXTERN SEMI {: RESULT = new Body() ;:};

// ### Block ###
block ::= LKEY field_decl_list:f_d_l list_statement:l_s RKEY {: RESULT = new Block(f_d_l, l_s) ;:}
        | LKEY field_decl_list:f_d_l RKEY {: RESULT = new Block(f_d_l, false) ;:}
        | LKEY list_statement:l_s RKEY {: RESULT = new Block(l_s, true) ;:}
        | LKEY RKEY {: RESULT = new Block(); :};

// ### List Statement ###
list_statement ::= statement:s {: ArrayList<Statement> list = new ArrayList<Statement>();
                                  list.add(s);
                                  RESULT = list;
                               :}
                 | list_statement:l_s statement:s {: l_s.add(s); RESULT = l_s;:};

// ### Types ###
type ::= INTEGER:i {: RESULT = new Type(i); :}
       | FLOAT:f  {: RESULT = new Type(f); :}
       | BOOL:b {: RESULT = new Type(b); :}
       | ID:id {: RESULT = new Type(id); :}
       | VOID:v {: RESULT = new Type(v); :};

// ### Statements ###
statement ::= location_expr:lo ASSIGNMENT expr:exp SEMI {: RESULT = new Assignment(lo, exp); :}
            | location_expr:lo ADDASSIGNMENT expr:exp SEMI {: RESULT = new AddAssignment(lo, exp); :}
            | location_expr:lo SUBASSIGNMENT expr:exp SEMI {: RESULT = new SubAssignment(lo, exp); :}
            | method_call_stmt:m_c_s SEMI {: RESULT = m_c_s; :}
            | FOR ID:id EQUALTO expr:condition COMMA expr:step statement:s {: RESULT = new ForStmt(new IdName(id), condition, step, s); :}
            | WHILE expr:exp statement:s {: RESULT = new WhileStmt(exp, s); :}
            | IF LPAREN expr:exp RPAREN statement:s optional_else:o_e {: RESULT = new IfStmt(exp, s, o_e); :}
            | RETURN expr:exp SEMI {: RESULT = new ReturnStmt(exp); :}
            | RETURN SEMI {: RESULT = new ReturnStmt(); :}
            | BREAK SEMI {: RESULT = new BreakStmt(); :}
            | CONTINUE SEMI {: RESULT = new ContinueStmt(); :}
            | SEMI
            | block:bl {: RESULT = bl; :};

lambda ::= {: RESULT = null; :};

//                          REVIEW THE ELSE
optional_else ::= ELSE statement:s {: RESULT =  s ;:}
                | lambda:l {: RESULT = l; :} ;

// ### Method Call ###
method_call_stmt ::= ID:id navigation:na LPAREN method_expr:m_e RPAREN {: RESULT = new MethodCallStmt(new IdName(id), na, m_e) ;:}
                   | ID:id LPAREN method_expr:m_e RPAREN {: RESULT = new MethodCallStmt(new IdName(id), m_e) ;:}
                   | ID:id navigation:na LPAREN RPAREN {: RESULT = new MethodCallStmt(new IdName(id), na) ;:}
                   | ID:id LPAREN RPAREN {: RESULT = new MethodCallStmt(new IdName(id)) ;:};

method_call_expr ::= ID:id navigation:na LPAREN method_expr:m_e RPAREN {: RESULT = new MethodCallExpr(new IdName(id), na, m_e) ;:}
                   | ID:id LPAREN method_expr:m_e RPAREN {: RESULT = new MethodCallExpr(new IdName(id), m_e) ;:}
                   | ID:id navigation:na LPAREN RPAREN {: RESULT = new MethodCallExpr(new IdName(id), na) ;:}
                   | ID:id LPAREN RPAREN {: RESULT = new MethodCallExpr(new IdName(id)) ;:};

//                         REVIEW THE NAVIGATION
// ### Navigation ###
navigation ::= POINT ID:id {: RESULT = new Navigation( new IdName(id)) ;:}
             | navigation:na POINT ID:id {: RESULT = new Navigation(na, new IdName(id));:};

//                          REVIEW THE METHOD EXPRESSION
method_expr ::= expr:e {: ArrayList<Expression> list = new ArrayList<Expression>();
                          list.add(e);
                          RESULT = list;
                       :}
              | method_expr:m_e expr:e {: m_e.add(e); RESULT = m_e; :};

//                          HEREEE DONE !
// ### Location ###
location_expr ::= ID:id {: RESULT = new LocationExpr(new IdName(id)) ;:}
                | ID:id location_aux:l_a {: RESULT = new LocationExpr(new IdName(id), l_a) ;:};
// this never is used
location_stmt ::= ID:id {: RESULT = new LocationStmt(new IdName(id)) ;:}
                | ID:id location_aux:l_a {: RESULT = new LocationStmt(new IdName(id), l_a) ;:};

location_aux ::= navigation:n {:  RESULT = n; :}
               | navigation:na LBRACKET expr:exp RBRACKET {: RESULT = new Navigation(na, exp); :};
