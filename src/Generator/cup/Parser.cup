package CodeGenerated;

import java_cup.runtime.*;

parser code {:
  public static void main(String args[]) throws Exception {
    ComplexSymbolFactory sf = new ComplexSymbolFactory();
    if (args.length==0) new Parser(new Scanner(System.in,sf),sf).parse();
    else new Parser(new Scanner(new java.io.FileInputStream(args[0]),sf),sf).parse();
  }

  public void syntax_error(Symbol sym){
    // Mute legacy Error Printing
  }
:}

terminal BOOL, INTEGER, FLOAT;
terminal BREAK, CONTINUE;
terminal IF, ELSE;
terminal FOR, WHILE;
terminal VOID;
terminal CLASS;
terminal RETURN, EXTERN;
terminal SEMI, COMMA;
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LKEY, RKEY;
terminal AND, OR, NOT;
terminal PERCENTAGE, DIVIDED,PLUS, MINUS, TIMES;
terminal LESS, LESSOREQ;
terminal GREATER, GREATEROREQ;
terminal EQUALTO, NOTEQUALTO;
terminal ADDASSIGNMENT, SUBASSIGNMENT, ASSIGNMENT;
terminal POINT;
terminal ID;

terminal Integer NUMBER_I;
terminal Float NUMBER_F;
terminal Boolean BOOLEAN_VALUE;

non terminal Expression expr;
non terminal ast;

non terminal Location location;
non terminal MethodCall method_call;
non terminal Program program;
non terminal FieldDecl field_decl;
non terminal MethodDecl method_decl;
non terminal ClassDecl class_decl;
non terminal Type type;
non terminal Param param;
non terminal Body body;
non terminal Block block;
non terminal Statement statement;
non terminal optional_else;
non terminal Navigation navigation;
non terminal method_expr;
non terminal lambda;
non terminal id_list;
non terminal IdName id_name;
non terminal field_decl_list;
non terminal LocationAux location_aux;
non terminal list_statement;
non terminal method_decl_list;

precedence left OR;
precedence left AND;
precedence left EQUALTO, NOTEQUALTO;
precedence left LESS, LESSOREQ, GREATER, GREATEROREQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDED, PERCENTAGE;
precedence left NOT;
precedence left ELSE;

start with program;

expr ::= location:lo {: RESULT = lo; :}
       | method_call:m_c {: RESULT = m_c :}
       | NUMBER_I:in {: RESULT = new Integer(in); :}
       | NUMBER_F:fl  {: RESULT = new Float(fl); :}
       | BOOLEAN_VALUE:bool {: RESULT = new Boolean(bool); :}
       | expr:l PLUS expr:r {: RESULT = new Plus(l r); :}
       | expr:l MINUS expr:r {: RESULT = new Minus(l, r); :}
       | expr:l TIMES expr:r {: RESULT = new Times(l, r); :}
       | expr:l DIVIDED expr:r {: RESULT = new Divided(l, r); :}
       | expr:l PERCENTAGE expr:r {: RESULT = new Percentage(l, r); :}
       | expr:l LESS expr:r {: RESULT = new Less(l, r); :}
       | expr:l GREATER expr:r {: RESULT = new Greater(l, r); :}
       | expr:l LESSOREQ expr:r {: RESULT = new LessOrEq(l, r); :}
       | expr:l GREATEROREQ expr:r {: RESULT = new GreaterOrEq(l, r); :}
       | expr:l EQUALTO expr:r {: RESULT = new EqualTo(l, r); :}
       | expr:l NOTEQUALTO expr:r {: RESULT = new NotEqualTo(l, r); :}
       | expr:l AND expr:r {: RESULT = new And(l, r); :}
       | expr:l OR expr:r {: RESULT = new Or(l, r); :}
       | MINUS expr:e {: RESULT = new Minus(e); :}
       | NOT expr:e {: RESULT = new Not(e) ; :}
       | LPAREN expr:exp RPAREN {: RESULT = exp; :};

lambda ::= {: RESULT = null; :};

program ::= class_decl:cl {: RESULT = new Program(cl); :}
          | program:p class_decl:cl {: p.addClass(cl); RESULT = p; :};

class_decl ::= CLASS ID:id LKEY field_decl_list:f_d_l method_decl_list:m_d_l RKEY {: RESULT = new ClassDecl(id, f_d_l, m_d_l) ;:}
             | CLASS ID:id LKEY field_decl_list:f_d_l RKEY {: RESULT = new ClassDecl(id, f_d_l) ;:}
             | CLASS ID:id LKEY method_decl_list:f_d_l RKEY {: RESULT = new ClassDecl(id, m_d_l) ;:}
             | CLASS ID:id LKEY RKEY {: RESULT = new ClassDecl(id) ;:};

field_decl_list ::= field_decl:f_d {: ArrayList<FieldDecl> list = new ArrayList<FieldDecl>();
                                      list.add(f_d); 
                                      RESULT = list; 
                                   :} 
                  | field_decl_list:f_d_l field_decl:f_d {: f_d_l.add(f_d); RESULT = f_d_l; :};

field_decl ::= type:t id_list:i_l SEMI {: RESULT = new FieldDecl(t, i_l) ;:};

id_list ::= id_name:i_n {: ArrayList<FieldDecl> list = new ArrayList<FieldDecl>();
                      list.add(i_n); 
                      RESULT = list; 
                    :}
          | id_list:i_l COMMA id_name:i_n {: i_l.add(i_n); RESULT = i_l; :};

id_name ::= ID:id {: RESULT = new IdName(id) ;:}
          | ID:id LBRACKET NUMBER_I:n_i RBRACKET  {: RESULT = new IdName(id, n_i) ;:};

method_decl_list ::= method_decl:m_d {: ArrayList<FieldDecl> list = new ArrayList<FieldDecl>();
                                        list.add(m_d); 
                                        RESULT = list; 
                                     :} 
                   | method_decl_list:m_d_l method_decl:m_d {: m_d_l.add(m_d); RESULT = m_d_l; :};

method_decl ::=  type:t ID:id LPAREN param:p RPAREN body:b {: RESULT = new MethodDecl(t, id, p, b) ;:}
               | type:t ID:id LPAREN RPAREN body:b {: RESULT = new MethodDecl(t, id, b) ;:};

param ::= type:t ID:id {: RESULT = new Param(t, id) ;:}
        | type:t ID:id COMMA param:p {: p.addParam(t, id);  RESULT = p; :}; // REFACTOR CLASS PARAM

body ::=  block:bl {: RESULT = new Body(bl) ;:}
        | EXTERN SEMI {: RESULT = new Body() ;:};



        
block ::= LKEY field_decl_list:f_d_l list_statement:l_s RKEY {: RESULT = new Block(f_d_l, l_s) ;:}
        | LKEY field_decl_list:f_d_l RKEY {: RESULT = new Block(f_d_l) ;:}
        | LKEY list_statement:l_s RKEY {: RESULT = new Block(l_s) ;:}
        | LKEY RKEY {: RESULT = new Block(): };


list_statement ::= statement:s {: ArrayList<Statement> list = new ArrayList<Statement>();
                                  list.add(s);
                                  RESULT = list;
                               :}
                 | list_statement:l_s statement:s {: l_s.add(s); :};

type ::= INTEGER {: RESULT = new Type(INTEGER): }
       | FLOAT  {: RESULT = new Type(FLOAT): }
       | BOOL {: RESULT = new Type(BOOL) ;:}
       | ID:id {: RESULT = new Type(id) ;:}
       | VOID {: RESULT = new Type(VOID): };

statement ::= location:lo ASSIGNMENT expr:exp SEMI {: RESULT = new Assignment(lo, exp); :}
            | location:lo ADDASSIGNMENT expr:exp SEMI {: RESULT = new AddAssignment(lo, exp); :}
            | location:lo SUBASSIGNMENT expr:exp SEMI {: RESULT = new SubAssignment(lo, exp); :}
            | method_call:m_c SEMI {: RESULT = m_c; :}
            | FOR ID:id EQUALTO expr:exp COMMA expr:exp statement:s {: RESULT = new For(id, exp, exp, s); :}
            | WHILE expr:exp statement:s {: RESULT = new While(exp, s); :}
            | IF LPAREN expr:exp RPAREN statement:s optional_else:o_e {: RESULT = new If(exp, s, o_e); :}
            | RETURN expr:exp SEMI {: RESULT = new Return(exp); :}
            | RETURN SEMI {: RESULT = new Return(); :}
            | BREAK SEMI {: RESULT = new Break(); :}
            | CONTINUE SEMI {: RESULT = new Continue(); :}
            | SEMI 
            | block:bl {: RESULT = bl; :};

// REVIEW THE ELSE
optional_else ::= ELSE statement:s {: RESULT =  s ;:}
                | lambda ;

method_call ::= ID:id navigation:na LPAREN method_expr RPAREN {: RESULT = new MethodCall(id, na, method_expr) ;:}
              | ID:id LPAREN method_expr:m_e RPAREN {: RESULT = new MethodCall(id, m_e) ;:}
              | ID:id navigation:na LPAREN RPAREN {: RESULT = new MethodCall(id, na) ;:}
              | ID:id LPAREN RPAREN {: RESULT = new MethodCall(id) ;:};

// REVIEW THE NAVIGATION
navigation ::= POINT ID:id {: RESULT = new Navigation( id) ;:}
              | navigation:na POINT ID:id {: RESULT = new Navigation(na, id);:};

// HEREEE DONE !
// REVIEW THE METHOD EXPRESSION
method_expr ::= expr
              | method_expr COMMA expr;

location ::= ID:id {: RESULT = new Location(id) ;:}
           | ID:id location_aux:l_a {: RESULT = new Location(id, l_a) ;:};

location_aux ::= navigation
               | navigation:na LBRACKET expr:exp RBRACKET {: RESULT = new LocationAux(na, exp) ;:};
