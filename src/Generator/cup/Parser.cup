package CodeGenerated;

import java_cup.runtime.*;
// import ASTClass.Ast.*;

parser code {:

  public static void main(String args[]) throws Exception {
    ComplexSymbolFactory sf = new ComplexSymbolFactory();
    if (args.length==0) new Parser(new Scanner(System.in,sf),sf).parse();
    else new Parser(new Scanner(new java.io.FileInputStream(args[0]),sf),sf).parse();
  }

  public void syntax_error(Symbol sym){
    // Mute legacy Error Printing
  }
:}

terminal BOOL, INTEGER, FLOAT;
terminal BREAK, CONTINUE;
terminal IF, ELSE;
terminal FOR, WHILE;
terminal VOID;
terminal CLASS;
terminal RETURN, EXTERN;
terminal SEMI, COMMA;
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LKEY, RKEY;
terminal AND, OR, NOT;
terminal PERCENTAGE, DIVIDED,PLUS, MINUS, TIMES;
terminal LESS, LESSOREQ;
terminal GREATER, GREATEROREQ;
terminal EQUALTO, NOTEQUALTO, EQUAL;
terminal ADDASSIGNMENT, SUBASSIGNMENT;
terminal POINT;
terminal ID;

terminal Integer NUMBER_I;
terminal Float NUMBER_F;
terminal Boolean BOOLEAN_VALUE;

non terminal expr;

non terminal bin_op, arith_op, rel_op, eq_op;
non terminal cond_op, literal;
non terminal location, method_call;
non terminal program, class_decl, field_decl, method_decl;
non terminal type, param, body, block;
non terminal statement, assignop, optional_else;
non terminal navigation, method_expr, lambda;
non terminal id_list, id_name, field_decl_list;
non terminal location_aux, list_field_decl, list_statement, method_decl_list;

precedence left OR;
precedence left AND;
precedence left EQUALTO, NOTEQUALTO;
precedence left LESS, LESSOREQ, GREATER, GREATEROREQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDED, PERCENTAGE;
precedence left NOT;
precedence left ELSE;

start with program;

// expr_list ::=   expr_list expr_part | expr_part;

// expr_part ::=   expr:e {: System.out.println(" = "+e.eval()+";"); :} SEMI
//               | fexp:e {: System.out.println(" = "+e.eval()+";"); :} SEMI
//               | boolexp:b {: System.out.println(" = "+b.eval()+";"); :} SEMI
//               | error:e SEMI:s {: parser.report_error("Syntax error in input from "+exleft +" to "+sxright,e); :};

// expr      ::=   NUMBER_I:n {: RESULT= new Expr.Const_i(nxleft,n,nxright); :}
//               | expr:l PLUS expr:r {: RESULT = new Expr.BinExpr(l,sym.PLUS,r); :}
//               | expr:l MINUS expr:r {: RESULT = new Expr.BinExpr(l,sym.MINUS,r); :}
//               | expr:l TIMES expr:r {: RESULT = new Expr.BinExpr(l,sym.TIMES,r); :}
//               | expr:l DIVIDED expr:r {: RESULT = new Expr.BinExpr(l,sym.DIVIDED,r); :}
//               | LPAREN expr:e RPAREN {: RESULT = e; :};

expr ::= location
       | method_call
       | literal
       | expr bin_op expr
       | MINUS expr
       | NOT expr
       | LPAREN expr RPAREN;

// boolexp   ::=   TRUE:t {: RESULT= new Expr.Const_b(null, t, null); :}
//               | FALSE:f {: RESULT= new Expr.Const_b(null, f, null); :}
//               | boolexp:l AND boolexp:r {: RESULT = new Expr.BooleanExpr(l, sym.AND, r); :}
//               | boolexp:l OR boolexp:r {: RESULT = new Expr.BooleanExpr(l, sym.OR, r); :}
//               | LPAREN boolexp:e RPAREN {: RESULT = e; :};

// fexp      ::=   NUMBER_F:n {: RESULT= new Expr.Const_f(nxleft,n,nxright); :}
//               | fexp:l PLUS fexp:r {: RESULT = new Expr.FloatExpr(l,sym.PLUS,r); :}
//               | fexp:l TIMES fexp:r {: RESULT = new Expr.FloatExpr(l,sym.TIMES,r); :}
//               | fexp:l MINUS fexp:r {: RESULT = new Expr.FloatExpr(l,sym.MINUS,r); :}
//               | fexp:l DIVIDED fexp:r {: RESULT = new Expr.FloatExpr(l,sym.DIVIDED,r); :}
//               | LPAREN fexp:e RPAREN {: RESULT = e; :};

lambda ::= ;

program ::= class_decl | program class_decl;

class_decl ::= CLASS ID LKEY field_decl_list method_decl_list RKEY
             | CLASS ID LKEY field_decl_list RKEY
             | CLASS ID LKEY method_decl_list RKEY
             | CLASS ID LKEY RKEY;

field_decl_list ::= field_decl | field_decl_list field_decl;

field_decl ::= type id_list SEMI;

id_list ::= id_name
          | id_list COMMA id_name;

id_name ::= ID | ID LBRACKET NUMBER_I RBRACKET;

method_decl_list ::= method_decl | method_decl_list method_decl;

method_decl ::=  type ID LPAREN param RPAREN body
               | type ID LPAREN RPAREN body;

param ::= type ID
        | type ID COMMA param;

body ::=  block
        | EXTERN SEMI;

block ::= LKEY list_field_decl list_statement RKEY
        | LKEY list_field_decl RKEY
        | LKEY list_statement RKEY
        | LKEY RKEY;

list_field_decl ::= field_decl | list_field_decl field_decl;

list_statement ::= statement | list_statement statement;

type ::= INTEGER | FLOAT | BOOL | ID | VOID;

statement ::= location assignop expr SEMI
            | method_call SEMI
            | IF LPAREN expr RPAREN statement optional_else
            | FOR ID EQUAL expr COMMA expr statement
            | WHILE expr statement
            | RETURN expr SEMI
            | RETURN SEMI
            | BREAK SEMI
            | CONTINUE SEMI
            | SEMI
            | block;

optional_else ::= ELSE statement
                | lambda ;

assignop ::= EQUAL | ADDASSIGNMENT | SUBASSIGNMENT;

method_call ::= ID navigation LPAREN method_expr RPAREN
              | ID LPAREN method_expr RPAREN
              | ID navigation LPAREN RPAREN
              | ID LPAREN RPAREN;

navigation ::= POINT ID | navigation POINT ID;

method_expr ::= expr
              | method_expr COMMA expr;

location ::= ID | ID location_aux;

location_aux ::= navigation | navigation LBRACKET expr RBRACKET;

bin_op ::= arith_op
         | rel_op
         | eq_op
         | cond_op;

arith_op ::= PLUS | MINUS | TIMES | DIVIDED | PERCENTAGE;

rel_op ::= LESS | GREATER | LESSOREQ | GREATEROREQ;

eq_op ::= EQUALTO | NOTEQUALTO;

cond_op ::= AND | OR;

literal ::= NUMBER_I | NUMBER_F | BOOLEAN_VALUE;


