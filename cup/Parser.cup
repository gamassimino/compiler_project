package Example;

import java_cup.runtime.*;
import Example.Parser.Expr;

parser code {:
  public static abstract class Expr<T> {
    public abstract T eval();
    public abstract Location right();
    public abstract Location left();


    // ################################
    // ######## Integer Class  ########
    // ################################
    static class BinExpr extends Expr<Integer> {
      Expr<Integer> l,r;
      int s;
      BinExpr(Expr<Integer> l, int sym, Expr<Integer> r){
        this.l=l;
        this.r=r;
        this.s=sym;
      }

      public Integer eval(){
        if (s == sym.PLUS) return l.eval() + r.eval();
        if (s == sym.TIMES) return l.eval() * r.eval();
        if (s == sym.MINUS) return l.eval() - r.eval();
        if (s == sym.DIVIDED) return l.eval() / r.eval();
        return 0;
      }

      public Location left() { return l.left(); }
      public Location right() { return r.right(); }
    }
    // - - - - - - - - -
    static class Const_i extends Expr<Integer> {
      Location l,r;
      Integer value;
      Const_i(Location l,Integer i,Location r){
        this.l=l;
        this.r=r;
        this.value = i;
      }

      public Integer eval(){ return value; }
      public Location left() { return l; }
      public Location right() {return r; }
    }
    // ################################
    // ######## Integer Class  ########
    // ################################



    // ##############################
    // ######## Float Class  ########
    // ##############################
    static class FloatExpr extends Expr<Float> {
      Expr<Float> l,r;
      int s;
      FloatExpr(Expr<Float> l, int sym, Expr<Float> r){
        this.l=l;
        this.r=r;
        this.s=sym;
      }

      public Float eval(){
        if (s == sym.PLUS) return l.eval() + r.eval();
        if (s == sym.TIMES) return l.eval() * r.eval();
        if (s == sym.MINUS) return l.eval() - r.eval();
        if (s == sym.DIVIDED) return l.eval() / r.eval();
        return new Float(0);
      }

      public Location left() { return l.left(); }
      public Location right() { return r.right(); }
    }
    // - - - - - - - - -
    static class Const_f extends Expr<Float> {
      Location l,r;
      Float value;
      Const_f(Location l, Float i, Location r){
        this.l=l;
        this.r=r;
        this.value = i;
      }
      public Float eval(){ return value; }
      public Location left() { return l; }
      public Location right() {return r; }
    }
    // ##############################
    // ######## Float Class  ########
    // ##############################



    // ################################
    // ######## Boolean Class  ########
    // ################################
    static class BooleanExpr extends Expr<Boolean> {
      Expr<Boolean> l,r;
      int s;

      BooleanExpr(Expr<Boolean> l, int sym, Expr<Boolean> r){
        this.l=l;
        this.r=r;
        this.s=sym;
      }

      public Boolean eval(){
        if (s == sym.AND) return l.eval() && r.eval();
        if (s == sym.OR) return l.eval() || r.eval();
        return true;
      }

      public Location left() { return l.left(); }
      public Location right() { return r.right(); }
    }
    // - - - - - - - - -
    static class Const_b extends Expr<Boolean> {
      Location l,r;
      Boolean value;
      Const_b(Location l, Boolean i, Location r){
        this.l=l;
        this.r=r;
        this.value = i;
      }
      public Boolean eval(){ return value;  }
      public Location left() { return l; }
      public Location right() {return r; }
    }
  }
  // ################################
  // ######## Boolean Class  ########
  // ################################



  public static void main(String args[]) throws Exception {
    ComplexSymbolFactory sf = new ComplexSymbolFactory();
    if (args.length==0) new Parser(new Scanner(System.in,sf),sf).parse();
    else new Parser(new Scanner(new java.io.FileInputStream(args[0]),sf),sf).parse();
  }

  public void syntax_error(Symbol sym){
    // Mute legacy Error Printing
  }
:}

terminal BOOL, INTEGER, FLOAT;
terminal BREAK, CONTINUE;
terminal IF, ELSE;
terminal FOR, WHILE;
terminal VOID;
terminal CLASS;
terminal RETURN, EXTERN;
terminal SEMI, COMMA;
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LKEY, RKEY;
terminal AND, OR, NOT;
terminal PERCENTAGE, DIVIDED,PLUS, MINUS, TIMES;
terminal LESS, LESSOREQ;
terminal GREATER, GREATEROREQ;
terminal EQUALTO, NOTEQUALTO, EQUAL;
terminal ADDASSIGNMENT, SUBASSIGNMENT;
terminal POINT;
terminal ID;

terminal Integer NUMBER_I;
terminal Float NUMBER_F;
terminal Boolean BOOLEAN_VALUE;

non terminal Expr expr;

non terminal bin_op, arith_op, rel_op, eq_op;
non terminal cond_op, literal;
non terminal location, method_call;
non terminal program, class_decl, field_decl, method_decl;
non terminal type, param, body, block;
non terminal statement, assignop, optional_else;
non terminal navigation, method_expr, lambda;
non terminal id_list, id_name, field_decl_list;
non terminal location_aux, list_field_decl, list_statement;

precedence left OR;
precedence left AND;
precedence left EQUALTO, NOTEQUALTO;
precedence left LESS, LESSOREQ, GREATER, GREATEROREQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIVIDED, PERCENTAGE;
precedence left NOT;
precedence left ELSE;

start with program;

// expr_list ::=   expr_list expr_part | expr_part;

// expr_part ::=   expr:e {: System.out.println(" = "+e.eval()+";"); :} SEMI
//               | fexp:e {: System.out.println(" = "+e.eval()+";"); :} SEMI
//               | boolexp:b {: System.out.println(" = "+b.eval()+";"); :} SEMI
//               | error:e SEMI:s {: parser.report_error("Syntax error in input from "+exleft +" to "+sxright,e); :};

// expr      ::=   NUMBER_I:n {: RESULT= new Expr.Const_i(nxleft,n,nxright); :}
//               | expr:l PLUS expr:r {: RESULT = new Expr.BinExpr(l,sym.PLUS,r); :}
//               | expr:l MINUS expr:r {: RESULT = new Expr.BinExpr(l,sym.MINUS,r); :}
//               | expr:l TIMES expr:r {: RESULT = new Expr.BinExpr(l,sym.TIMES,r); :}
//               | expr:l DIVIDED expr:r {: RESULT = new Expr.BinExpr(l,sym.DIVIDED,r); :}
//               | LPAREN expr:e RPAREN {: RESULT = e; :};

expr ::= location
       | method_call
       | literal
       | expr bin_op expr
       | MINUS expr
       | NOT expr
       | LPAREN expr RPAREN;

// boolexp   ::=   TRUE:t {: RESULT= new Expr.Const_b(null, t, null); :}
//               | FALSE:f {: RESULT= new Expr.Const_b(null, f, null); :}
//               | boolexp:l AND boolexp:r {: RESULT = new Expr.BooleanExpr(l, sym.AND, r); :}
//               | boolexp:l OR boolexp:r {: RESULT = new Expr.BooleanExpr(l, sym.OR, r); :}
//               | LPAREN boolexp:e RPAREN {: RESULT = e; :};

// fexp      ::=   NUMBER_F:n {: RESULT= new Expr.Const_f(nxleft,n,nxright); :}
//               | fexp:l PLUS fexp:r {: RESULT = new Expr.FloatExpr(l,sym.PLUS,r); :}
//               | fexp:l TIMES fexp:r {: RESULT = new Expr.FloatExpr(l,sym.TIMES,r); :}
//               | fexp:l MINUS fexp:r {: RESULT = new Expr.FloatExpr(l,sym.MINUS,r); :}
//               | fexp:l DIVIDED fexp:r {: RESULT = new Expr.FloatExpr(l,sym.DIVIDED,r); :}
//               | LPAREN fexp:e RPAREN {: RESULT = e; :};

lambda ::= ;

program ::= class_decl | program class_decl;

class_decl ::= CLASS ID LKEY field_decl_list method_decl RKEY
             | CLASS ID LKEY field_decl RKEY
             | CLASS ID LKEY method_decl RKEY
             | CLASS ID LKEY RKEY;

field_decl_list ::= field_decl
                  | field_decl_list field_decl;

field_decl ::= type id_list SEMI;

id_list ::= id_name
          | id_list COMMA id_name;

id_name ::= ID | ID LBRACKET NUMBER_I RBRACKET;

method_decl ::=  type ID LPAREN param RPAREN body
               | type ID LPAREN RPAREN body;

param ::= type ID
        | type ID COMMA param;

body ::=  block
        | EXTERN SEMI;

block ::= LKEY list_field_decl list_statement RKEY
        | LKEY list_field_decl RKEY
        | LKEY list_statement RKEY
        | LKEY RKEY;

list_field_decl ::= field_decl | list_field_decl field_decl;

list_statement ::= statement | list_statement statement;

type ::= INTEGER | FLOAT | BOOL | ID | VOID;

statement ::= location assignop expr SEMI
            | method_call
            | IF LPAREN expr RPAREN statement optional_else
            | FOR ID EQUAL expr COMMA expr statement
            | WHILE expr statement
            | RETURN expr SEMI
            | RETURN SEMI
            | BREAK SEMI
            | CONTINUE SEMI
            | SEMI
            | block;

optional_else ::= ELSE statement
                | lambda ;

assignop ::= EQUAL | ADDASSIGNMENT | SUBASSIGNMENT;

method_call ::= ID navigation LPAREN method_expr RPAREN
              | ID LPAREN method_expr RPAREN
              | ID navigation LPAREN RPAREN
              | ID LPAREN RPAREN;

navigation ::= POINT ID | navigation POINT ID;

method_expr ::= expr
              | method_expr COMMA expr;

location ::= ID | ID location_aux;

location_aux ::= navigation | navigation LBRACKET expr RBRACKET;

bin_op ::= arith_op
         | rel_op
         | eq_op
         | cond_op;

arith_op ::= PLUS | MINUS | TIMES | DIVIDED | PERCENTAGE;

rel_op ::= LESS | GREATER | LESSOREQ | GREATEROREQ;

eq_op ::= EQUALTO | NOTEQUALTO;

cond_op ::= AND | OR;

literal ::= NUMBER_I | NUMBER_F | BOOLEAN_VALUE;


