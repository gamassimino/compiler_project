package Example;

import java_cup.runtime.*;
import Example.Parser.Expr;

parser code {:
  public static abstract class Expr<T> {
    public abstract T eval();
    public abstract Location right();
    public abstract Location left();


    // ################################
    // ######## Integer Class  ########
    // ################################
    static class BinExpr extends Expr<Integer> {
      Expr<Integer> l,r;
      int s;
      BinExpr(Expr<Integer> l, int sym, Expr<Integer> r){
        this.l=l;
        this.r=r;
        this.s=sym;
      }

      public Integer eval(){
        if (s == sym.PLUS) return l.eval() + r.eval();
        if (s == sym.TIMES) return l.eval() * r.eval();
        if (s == sym.MINUS) return l.eval() - r.eval();
        if (s == sym.DIVIDED) return l.eval() / r.eval();
        return 0;
      }

      public Location left() { return l.left(); }
      public Location right() { return r.right(); }
    }
    // - - - - - - - - -
    static class Const_i extends Expr<Integer> {
      Location l,r;
      Integer value;
      Const_i(Location l,Integer i,Location r){
        this.l=l;
        this.r=r;
        this.value = i;
      }

      public Integer eval(){ return value; }
      public Location left() { return l; }
      public Location right() {return r; }
    }
    // ################################
    // ######## Integer Class  ########
    // ################################



    // ##############################
    // ######## Float Class  ########
    // ##############################
    static class FloatExpr extends Expr<Float> {
      Expr<Float> l,r;
      int s;
      FloatExpr(Expr<Float> l, int sym, Expr<Float> r){
        this.l=l;
        this.r=r;
        this.s=sym;
      }

      public Float eval(){
        if (s == sym.PLUS) return l.eval() + r.eval();
        if (s == sym.TIMES) return l.eval() * r.eval();
        if (s == sym.MINUS) return l.eval() - r.eval();
        if (s == sym.DIVIDED) return l.eval() / r.eval();
        return new Float(0);
      }

      public Location left() { return l.left(); }
      public Location right() { return r.right(); }
    }
    // - - - - - - - - -
    static class Const_f extends Expr<Float> {
      Location l,r;
      Float value;
      Const_f(Location l, Float i, Location r){
        this.l=l;
        this.r=r;
        this.value = i;
      }
      public Float eval(){ return value; }
      public Location left() { return l; }
      public Location right() {return r; }
    }
    // ##############################
    // ######## Float Class  ########
    // ##############################



    // ################################
    // ######## Boolean Class  ########
    // ################################
    static class BooleanExpr extends Expr<Boolean> {
      Expr<Boolean> l,r;
      int s;

      BooleanExpr(Expr<Boolean> l, int sym, Expr<Boolean> r){
        this.l=l;
        this.r=r;
        this.s=sym;
      }

      public Boolean eval(){
        if (s == sym.AND) return l.eval() && r.eval();
        if (s == sym.OR) return l.eval() || r.eval();
        return true;
      }

      public Location left() { return l.left(); }
      public Location right() { return r.right(); }
    }
    // - - - - - - - - -
    static class Const_b extends Expr<Boolean> {
      Location l,r;
      Boolean value;
      Const_b(Location l, Boolean i, Location r){
        this.l=l;
        this.r=r;
        this.value = i;
      }
      public Boolean eval(){ return value;  }
      public Location left() { return l; }
      public Location right() {return r; }
    }
  }
  // ################################
  // ######## Boolean Class  ########
  // ################################



  public static void main(String args[]) throws Exception {
    ComplexSymbolFactory sf = new ComplexSymbolFactory();
    if (args.length==0) new Parser(new Scanner(System.in,sf),sf).parse();
    else new Parser(new Scanner(new java.io.FileInputStream(args[0]),sf),sf).parse();
  }

  public void syntax_error(Symbol sym){
    // Mute legacy Error Printing
  }
:}

terminal BOOL, INTEGER, FLOAT;
terminal BREAK, CONTINUE;
terminal IF, ELSE;
terminal FOR, WHILE;
terminal VOID, NULL;
terminal CLASS;
terminal RETURN, EXTERN;
terminal SEMI, COMMA;
terminal LPAREN, RPAREN, LBRACKET, RBRACKET, LKEY, RKEY;
terminal AND, OR, NOT;
terminal PERCENTAGE, DIVIDED,PLUS, MINUS, TIMES;
terminal LESS, LESSOREQ;
terminal GREATER, GREATEROREQ;

terminal EQUALTO, NOTEQUALTO;

terminal Integer NUMBER_I;
terminal Float NUMBER_F;
terminal Boolean TRUE, FALSE;

non terminal expr_list, expr_part;
non terminal Expr expr;
non terminal Expr boolexp;
non terminal Expr fexp;

non terminal bin_op, arith_op, rel_op, eq_op;
non terminal cond_op, literal, id , alpha_num_aux;
non terminal alpha_num, alpha, digit, int_literal;
non terminal int_literal_aux, bool_literal, flaot_literal;

precedence left PLUS;
precedence left MINUS;
precedence left TIMES;
precedence left DIVIDED;

precedence left OR;
precedence left AND;


expr_list ::=   expr_list expr_part | expr_part;

expr_part ::=   expr:e {: System.out.println(" = "+e.eval()+";"); :} SEMI
              | fexp:e {: System.out.println(" = "+e.eval()+";"); :} SEMI
              | boolexp:b {: System.out.println(" = "+b.eval()+";"); :} SEMI
              | error:e SEMI:s {: parser.report_error("Syntax error in input from "+exleft +" to "+sxright,e); :};

expr      ::=   NUMBER_I:n {: RESULT= new Expr.Const_i(nxleft,n,nxright); :}
              | expr:l PLUS expr:r {: RESULT = new Expr.BinExpr(l,sym.PLUS,r); :}
              | expr:l MINUS expr:r {: RESULT = new Expr.BinExpr(l,sym.MINUS,r); :}
              | expr:l TIMES expr:r {: RESULT = new Expr.BinExpr(l,sym.TIMES,r); :}
              | expr:l DIVIDED expr:r {: RESULT = new Expr.BinExpr(l,sym.DIVIDED,r); :}
              | LPAREN expr:e RPAREN {: RESULT = e; :};

expr ::= location
       | method_call
       | literal
       | expr bin_op expr
       | MINUS expr
       | NOT expr
       | LPAREN expr RPAREN

boolexp   ::=   TRUE:t {: RESULT= new Expr.Const_b(null, t, null); :}
              | FALSE:f {: RESULT= new Expr.Const_b(null, f, null); :}
              | boolexp:l AND boolexp:r {: RESULT = new Expr.BooleanExpr(l, sym.AND, r); :}
              | boolexp:l OR boolexp:r {: RESULT = new Expr.BooleanExpr(l, sym.OR, r); :}
              | LPAREN boolexp:e RPAREN {: RESULT = e; :};

fexp      ::=   NUMBER_F:n {: RESULT= new Expr.Const_f(nxleft,n,nxright); :}
              | fexp:l PLUS fexp:r {: RESULT = new Expr.FloatExpr(l,sym.PLUS,r); :}
              | fexp:l TIMES fexp:r {: RESULT = new Expr.FloatExpr(l,sym.TIMES,r); :}
              | fexp:l MINUS fexp:r {: RESULT = new Expr.FloatExpr(l,sym.MINUS,r); :}
              | fexp:l DIVIDED fexp:r {: RESULT = new Expr.FloatExpr(l,sym.DIVIDED,r); :}
              | LPAREN fexp:e RPAREN {: RESULT = e; :};


program ::= class_decl | program class_decl;

class_decl ::= CLASS id LKEY field_decl method_decl RKEY
            | CLASS id LKEY field_decl RKEY
            | CLASS id LKEY method_decl RKEY
            | CLASS id LKEY RKEY

field_decl ::= type id SEMI
              |type id LBRACKET int_literal RBRACKET SEMI
              |type field_decl_aux SEMI

field_decl_aux ::= id COMMA field_decl_aux
                  |id LBRACKET int_literal RBRACKET COMMA field_decl_aux
                  |NULL

method_decl ::= type id LPAREN param RPAREN body
                |type id LPAREN RPAREN body

param ::= type id |type id COMMA param

body ::= block | EXTERN SEMI

block ::= LKEY field_decl_aux statement_aux RKEY

field_decl_aux ::= field_decl field_decl_aux | NULL

statement_aux ::= statement statement_aux | NULL

type ::= INTEGER | FLOAT | BOOL | id | VOID

statement ::= location assignop expr SEMI
            | method_call
            |IF LPAREN expr RPAREN statement optional_else
            |FOR id EQUAL expr COMMA expr statement
            |WHILE expr statement
            |RETURN expr SEMI
            |RETURN NULL SEMI
            |BREAK SEMI
            |CONTINUE SEMI
            |SEMI
            |block

optional_else ::= ELSE statement | NULL

assignop := EQUAL | ADDASSIGNMENT | SUBASSIGNMENT

method_call ::= id navigation LPAREN method_expr RPAREN

navigation ::= POINT id | POINT id navigation | NULL

method_expr ::= expr | expr SEMI method_expr | NULL

location ::= id navigation
            |id navigation LBRACKET expr RBRACKET

// bin_op ::= arith_op | rel_op | eq_op | cond_op

// arith_op ::= PLUS | MINUS | TIMES | DIVIDED | PERCENTAGE

// rel_op ::= LESS | GREATER | LESSOREQ | GREATEROREQ

// eq_op ::= EQUALTO | NOTEQUALTO

// cond_op ::= AND | OR

// literal ::= int_literal | flaot_literal | bool_literal

// id  ::= alpha | alpha  alpha_num_aux

// alpha_num_aux ::= alpha_num alpha_num_aux | _

// alpha_num ::= alpha | digit | _

// alpha ::= a | b | c | d | e | f | g | h | i | j | k | l | m | n | Ã± | o | p | q | r | s | t | u | v | w | x | y | z

// digit ::= NUMBER

// int_literal ::= digit int_literal_aux

// int_literal_aux ::= digit int_literal_aux | _

// bool_literal ::= TREU | FALSE

// flaot_literal ::= int_literal . int_literal